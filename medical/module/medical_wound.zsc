class UaS_BleedingWound : HDBleedingWound {
	string Description;
	int Type;

	override void Tick() {
		BleedWound();
		if (checkdestroy()) { destroy(); return; }
		if (checkskip()) { return; }
		super.Tick();
	}

	void BleedWound() {
		// Calculate offset
		vector3 off = (
			cos(location.x+bleeder.angle) * bleeder.radius * 0.7,
			sin(location.x+bleeder.angle) * bleeder.radius * 0.7,
			location.y * bleeder.height);
		// Spawn a wound particle;
		bleeder.A_SpawnParticle(
			"DarkRed",
			//flags: SPF_RELATIVE,
			lifetime: 1,
			size: (width*0.5)+(depth*0.5)*0.5,
			xoff: off.x,
			yoff: off.y,
			zoff: off.z,
			velx: bleeder.vel.x,
			vely: bleeder.vel.y,
			velz: bleeder.vel.z,
			startalphaf: 0.5,
			fadestepf: 0);
		// Maybe spawn a blood drop depending on depth
		if (random[ubw](1,10) > depth) { return; }
		bleeder.A_SpawnParticle(
			"DarkRed",
			//flags: SPF_RELATIVE,
			lifetime: random[ubw](10,20),
			size: frandom[ubw](1,3),
			xoff: off.x + frandom[ubw](-width, width) * 0.1,
			yoff: off.y + frandom[ubw](-width, width) * 0.1,
			zoff: off.z + frandom[ubw](-width, width) * 0.1,
			accelz: -bleeder.gravity,
			fadestepf: 0);
		// if (random[ubw](0,5)!=0) { return; }
		// bleeder.A_SpawnParticle(
			// "DarkRed",
			// lifetime: random[ubw](10,35),
			// size: frandom[ubw](2,6),
			// xoff: off.x + frandom[ubw](-3,3),
			// yoff: off.y + frandom[ubw](-3,3),
			// zoff: bleeder.getzat(off.x, off.y) + 0.1,
			// fadestepf: 0);
	}

	// static string WoundDescription(int newsize) {
		// int sevmax = WoundInfo.severity.size()-1;
		// int typmax = WoundInfo.type.size()-1;
		// int parmax = WoundInfo.bodypart.size()-1;
		// return string.format(
			// "%s %s, %s",
			// WoundInfo.severity[random[uas_wi](0, sevmax)],
			// WoundInfo.type[random[uas_wi](0, typmax)],
			// WoundInfo.bodypart[random[uas_wi](0, parmax)]
		// );
	// }

	static UaS_BleedingWound Create(HDBleedingWound bw) {
		UaS_BleedingWound uw = new("UaS_BleedingWound");
		// Copy stuff from original wound
		uw.bleeder = bw.bleeder;
		uw.source = bw.source;
		uw.depth = bw.depth;
		uw.width = bw.width;
		uw.patched = bw.patched;
		uw.sealed = bw.sealed;
		uw.regenrate = bw.regenrate;
		uw.damagetype = bw.damagetype;
		uw.location = bw.location;
		// Add expanded details
		//console.printf("location "..bw.location);
		if (bw.location.y >= 0.85) { uw.type = UWL_HEAD; console.printf("headwound!"); }
		return uw;
	}

	static const string[] w_severity = {
		"minor","small","shallow",
		"superficial","moderate","medium",
		"large","deep","serious","critical" };
	static const string[] w_type = {
		"incision","laceration","puncture",
		"avulsion","penetration" };
	static const string[] w_bodypart = {
		"chest","abdomen","pelvis",
		"upper back","lower back",
		"left shoulder","right shoulder",
		"left upper arm","right upper arm",
		"left forearm","right forearm",
		"left hip","right hip",
		"left thigh","right thigh",
		"left calf","right calf",
		"left shin","right shin"
	};
}
enum UaS_BodyParts {
	UWL_L_ARM,
	UWL_R_ARM,
	UWL_L_LEG,
	UWL_R_LEG,
	UWL_TORSO,
	UWL_JUNCTIONAL,
	UWL_HEAD
}
