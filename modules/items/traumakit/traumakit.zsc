#include "modules/items/traumakit/traumakit_painkiller.zsc"
#include "modules/items/traumakit/traumakit_forceps.zsc"
#include "modules/items/traumakit/traumakit_stapler.zsc"
#include "modules/items/traumakit/traumakit_sutures.zsc"
#include "modules/items/traumakit/traumakit_scalpel.zsc"
#include "modules/items/traumakit/traumakit_biofoam.zsc"
#include "modules/items/traumakit/traumakit_saline.zsc"
#include "modules/items/traumakit/traumakit_helptext.zsc"
#include "modules/items/traumakit/traumakit_pain.zsc"
#include "modules/items/traumakit/traumakit_supplies.zsc"
#include "modules/items/traumakit/spawner.zsc"

class UaS_TraumaKit : HDWeapon {
	string statusMessage;
	StatusInfo currentMessage;
	WoundInfo currentWound;
	UaS_WoundHandler wh;
	HDPlayerPawn patient, lastpatient;
	transient cvar autostrip;

	Default {
		radius 4;
		height 4;
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		Inventory.PickupMessage "Picked up a personal trauma kit.";
		Inventory.Icon "UGSIF0";
		Inventory.PickupSound "weapons/pocket";
		+INVENTORY.INVBAR;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.IGNORESKILL;
		+WEAPON.NO_AUTO_SWITCH;
		+hdweapon.fitsinbackpack;
		//+WEAPON.NOAUTOFIRE;
		weapon.slotpriority 0.5;
		weapon.slotnumber 9;
		hdweapon.refid UAS_HDLD_TRAUMAKIT;
		scale 0.5;
		tag "Trauma Kit";
	}

	override double weaponbulk(){
		double b = 0;
		b += (weaponstatus[TKS_PAINKILLER] / 20) * (ENC_STIMPACK * 0.4);
		b += (weaponstatus[TKS_SALINE] / 1000) * (ENC_STIMPACK * 2 * 0.8);
		b += (weaponstatus[TKS_BIOFOAM] / 250) * (6 * 0.6);
		b += (weaponstatus[TKS_STAPLES] / 25) * (6 * 0.1);
		b = max(b, 15);
		return b;
	}

	states {
		spawn:
			UGSI F -1;
			stop;
	}

	override void DoEffect() {
		if (!(owner.player.readyweapon is 'UaS_TraumaKit')) { return; }
		statusMessage = "--- \cyTrauma Kit\c- ---\n";

		if (patient) { statusMessage = statusmessage.."Treating \cg"..patient.player.getusername().."\n\n"; }
		else { statusMessage = statusmessage.."\n\n"; }

		SetHelpText();
		SetPatient();
		WoundList();
		CycleWounds();
		CycleTools();
		HandleSupplies();

		switch (weaponstatus[TK_SELECTED]) {
			case T_PAINKILLER:
				HandlePainkiller();
				break;
			case T_SALINE:
				HandleSaline();
				break;
			case T_FORCEPS:
				HandleForceps();
				break;
			case T_BIOFOAM:
				HandleBiofoam();
				break;
			case T_STAPLER:
				HandleStapler();
				break;
			case T_SUTURES:
				HandleSutures();
				break;
			case T_SCALPEL:
				HandleScalpel();
				break;
		}

		if (currentWound) { statusmessage = statusmessage..currentWound.WoundStatus().."\n"; }

		TickMessages();
		A_WeaponMessage(statusMessage);
	}

	// Somewhat copied from HD, largely rewritten
	bool HandleStrip() {
		if (!autostrip) { autostrip = CVar.GetCVar("hd_autostrip", owner.player); }
		string itemname, imperative;
		// check for worn items, otherwise exit early
		if(patient.countinv("WornRadsuit")) { itemname = "environment suit "; }
		else if(patient.countinv("HDArmourWorn")) { itemname = "armour "; }
		else { return true; }

		// check owner or other
		if(patient == owner) {
			imperative = "Take off your ";
			//handle autostrip
			if(autostrip.GetBool()) {
				HDPlayerPawn.CheckStrip(owner, -1);
				return false;
			}
		}
		else {
			imperative = "Have them take off their ";
		}
		// display message
		currentmessage.text = imperative..itemname.."first!\n";
		currentmessage.timeout = 2*35;
		return false;
	}

	void SetPatient() {
		HDPlayerPawn other;
		FLineTraceData tktrace;
		owner.LineTrace(owner.angle, 42, owner.pitch, offsetz: owner.height-12, data: tktrace);
		if (tktrace.hitactor && tktrace.hitactor is "HDPlayerPawn") { other = HDPlayerPawn(tktrace.hitactor); }

		if (other && (owner.player.cmd.buttons & BT_ZOOM)) { patient = other; }
		if (!patient || levellocals.Vec3Diff(owner.pos, patient.pos).length() > owner.radius * 4) { patient = HDPlayerPawn(owner); }

		A_StopTreating(); // let current woundhandler (if it exists) know we're done
		wh = UaS_WoundHandler(patient.FindInventory('UaS_WoundHandler'));
		if (!wh) { console.printf("No wound handler!"); return; }
		wh.treating_kits.push(self);
		if (patient != lastpatient) { currentWound = null; }
		lastpatient = patient;
	}

	action void A_StopTreating(){
		if (!wh) { return; }
		int self_idx = wh.treating_kits.find(self);
		if (!self_idx) { return; }
		wh.treating_kits.delete(self_idx);
	}

	states{
	deselect:
		TNT1 A 0 A_StopTreating();
		TNT1 A 0 A_StartDeselect();
	}

	void TickMessages() {
		// Tick down transient messages
		if (currentmessage.timeout > 0) {
			statusmessage = statusmessage..currentmessage.text;
			currentmessage.timeout--;
		}
	}

	void WoundList() {
		if (wh.critwounds.size() == 0) {
			statusmessage = statusmessage.."No treatable wounds\n\n";
			return;
		}
		int loopmin = min(weaponstatus[TK_WOUNDINDEX] - 2, wh.critwounds.size() - 5);
		int loopmax = max(weaponstatus[TK_WOUNDINDEX] + 2, 4);
		if (loopmin > 0) { statusmessage = statusmessage..". . .\n"; }
		else { statusmessage = statusmessage.."\n"; }
		for (int i = loopmin; i <= loopmax; i++) {
			if(i<0 || i > wh.critwounds.size()-1) { continue; }
			string hilite;
			if (currentWound == wh.critwounds[i]) {
				if (wh.critwounds[i].AverageStatus() >= 15) { hilite = "\ca"; }
				else { hilite = "\cd"; }
			}
			else {
				if (wh.critwounds[i].AverageStatus() >= 15) { hilite = "\cr"; }
 				else { hilite = "\cq"; }
 			}
			statusmessage = statusmessage..hilite..wh.critwounds[i].description.."\n";
		}
		if (loopmax < wh.critwounds.size() - 1) { statusmessage = statusmessage..". . .\n"; }
		else { statusmessage = statusmessage.."\n"; }
		statusmessage = statusmessage.."\n";
	}

	void CycleWounds() {
		if (!currentWound) { weaponstatus[TK_WOUNDINDEX] = -1; }
		if (wh.critwounds.size() == 0) { return; }
		if (!(owner.player.cmd.buttons & BT_FIREMODE)) { return; }
		if ((owner.player.cmd.buttons & BT_RELOAD) && !(owner.player.oldbuttons & BT_RELOAD)) {
			weaponstatus[TK_WOUNDINDEX] = (weaponstatus[TK_WOUNDINDEX] + 1) % wh.critwounds.size();
			currentWound = GetWound(weaponstatus[TK_WOUNDINDEX]);
		}
		else if ((owner.player.cmd.buttons & BT_ALTRELOAD) && !(owner.player.oldbuttons & BT_ALTRELOAD)) {
			weaponstatus[TK_WOUNDINDEX] = (weaponstatus[TK_WOUNDINDEX] - 1) % wh.critwounds.size();
			if(weaponstatus[TK_WOUNDINDEX] < 0) { weaponstatus[TK_WOUNDINDEX] = wh.critwounds.size() - 1; }
			currentWound = GetWound(weaponstatus[TK_WOUNDINDEX]);
		}
	}

	void CycleTools(int set = -1) {
		if ((owner.player.cmd.buttons & BT_FIREMODE)) { return; }
		if (set != -1) { weaponstatus[TK_SELECTED] = set; return; }
		if ((owner.player.cmd.buttons & BT_RELOAD) && !(owner.player.oldbuttons & BT_RELOAD)) {
			weaponstatus[TK_SELECTED] = (weaponstatus[TK_SELECTED] + 1) % 7;
			weaponstatus[TK_HOLD] = 0;
			currentmessage.text = "";
			currentmessage.timeout = 0;
		}
		else if ((owner.player.cmd.buttons & BT_ALTRELOAD) && !(owner.player.oldbuttons & BT_ALTRELOAD)) {
			weaponstatus[TK_SELECTED] = (weaponstatus[TK_SELECTED] - 1);
			if(weaponstatus[TK_SELECTED] < 0) { weaponstatus[TK_SELECTED] = 6; }
			weaponstatus[TK_HOLD] = 0;
			currentmessage.text = "";
			currentmessage.timeout = 0;
		}
	}

	WoundInfo GetWound(int index) {
		if (wh.critwounds.size() <= 0) { return null; }
		return wh.critwounds[index];
	}

	// Copied from HD, non-action version
	void PlaySkinSound(int which,sound fallback,int channel=CHAN_VOICE,int flags=0){
		let ppp=hdplayerpawn(owner);
		sound sss;
		if(ppp)switch(which){
		case SKINSOUND_TAUNT:sss=ppp.tauntsound;break;
		case SKINSOUND_XDEATH:sss=ppp.xdeathsound;break;
		case SKINSOUND_GRUNT:sss=ppp.gruntsound;break;
		case SKINSOUND_LAND:sss=ppp.landsound;break;
		case SKINSOUND_MEDS:sss=ppp.medsound;break;
		default:return;
		}
		else sss=fallback;
		owner.A_StartSound(sss,channel,flags);
	}

	void DebugStatus() {
		if (currentWound) {
			statusmessage = statusmessage.."dirty "..currentWound.dirty.."\n";
			statusmessage = statusmessage.."obstructed "..currentWound.obstructed.."\n";
			statusmessage = statusmessage.."open "..currentWound.open.."\n";
			statusmessage = statusmessage.."cavity "..currentWound.cavity.."\n";
			statusmessage = statusmessage.."infection "..currentWound.infection.."\n";
			statusmessage = statusmessage.."timer "..currentWound.timer.."\n";
		}
		statusMessage = statusMessage.."\n";
		statusMessage = statusMessage.."Open Wounds "..patient.woundcount.."\n";
		statusMessage = statusMessage.."Unstable Wounds "..patient.unstablewoundcount.."\n";
		statusMessage = statusMessage.."Old Wounds "..patient.oldwoundcount.."\n";
	}

	struct StatusInfo {
		string text;
		int timeout;
	}

	enum ToolModes {
		T_PAINKILLER,
		T_SALINE,
		T_FORCEPS,
		T_BIOFOAM,
		T_STAPLER,
		T_SUTURES,
		T_SCALPEL,
	}

	enum KitFlags {
		//standard slots
		TK_SELECTED,
		TK_BUTTON,
		TK_HOLD,
		TK_WOUNDINDEX,

		//supply slots
		TKS_PAINKILLER,
		TKS_SALINE,
		TKS_BIOFOAM,
		TKS_STAPLES,
	}
}
