extend class UaS_Messkit {
	override void Tick() {
		BuildFoodList();
		CleanFoodList();
		bINVBAR = (foodarray.size() > 0);
		Consume();
	}

	void BuildFoodList() {
		foodarray.clear();
		let i = owner.inv;
		while (i) {
			if (i is 'UaS_Consumable') {
				UaS_Consumable fi = UaS_Consumable(i);
				foodarray.push(fi);
			}
			i = i.inv;
		}
	}

	void CleanFoodList() {
		for (int i=0; i < foodarray.size(); i++) {
			bool energygone = (foodarray[i].energy - foodarray[i].energy_consumed <= 0);
			bool fluidgone = (foodarray[i].fluid - foodarray[i].fluid_consumed <= 0);
			if (energygone && fluidgone) {
				foodarray[i].amount--;
				foodarray[i].energy_consumed = 0;
				foodarray[i].fluid_consumed = 0;
				if (foodarray[i].amount <= 0) owner.TakeInventory(foodarray[i].GetClassName());
			}
		}
	}

	void Consume() {
		if (mouthclear()) { return; }
		if (weaponstatus[MKS_BITE] > 0 && level.maptime % 5 == 0) {
			owner.A_StartSound("UaS/Chew", CHAN_VOICE, CHANF_NOSTOP, volume: frandom[uas_mk](0.4, 0.75));
			weaponstatus[MKS_BITE] -= min(random[uas_mk](1,10), weaponstatus[MKS_BITE]);
			console.printf("chewing "..weaponstatus[MKS_BITE]);
		}
		else if (weaponstatus[MKS_SIP] > 0 && weaponstatus[MKS_BITE] <= 0) {
			weaponstatus[MKS_SIP]--;
			owner.A_StartSound("UaS/Sip", CHAN_VOICE, CHANF_NOSTOP, volume: frandom[uas_mk](0.25, 0.5));
			console.printf("Sipping "..weaponstatus[MKS_SIP]);
		}
		if (mouthclear()) {
			console.printf("Swallowed");
			owner.A_StartSound("UaS/Swallow", CHAN_VOICE);
			return;
		}
	}
}
