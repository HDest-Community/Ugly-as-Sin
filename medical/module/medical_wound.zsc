class UaS_BloodParticle {
	double size, maxsize, maxz;
	vector3 pos, oldpos, vel, oldvel;
	int startlife;
}

class UaS_BleedingWound : HDBleedingWound {
	string Description;
	int Type;
	array<UaS_BloodParticle> drops;
	FSpawnParticleParams BP;
	vector3 oldpos;

	override void Tick() {
		BloodDrops();
		if (checkdestroy()) { destroy(); return; }
		if (checkskip()) { return; }
		super.Tick();
	}

	void BloodDrops() {
		// Calculate offset
		vector3 off = bleeder.pos + (
			cos(location.x+bleeder.angle) * bleeder.radius * 0.7,
			sin(location.x+bleeder.angle) * bleeder.radius * 0.7,
			location.y * bleeder.height);
		vector3 interpvel = level.Vec3Diff(oldpos, off);
		double avgsize = (width + depth) / 2.0;

		// Spawn a wound particle;
		if (depth >= 8) { BP.Texture = TexMan.CheckForTexture ("BLUDC0"); }
		else if (depth >= 4) { BP.Texture = TexMan.CheckForTexture ("BLUDB0"); }
		else if (depth >= 1) { BP.Texture = TexMan.CheckForTexture ("BLUDA0"); }
		else { BP.Texture = TexMan.CheckForTexture (""); }
		BP.Color1 = "DarkRed";
		BP.Pos = oldpos;
		BP.Lifetime = 1;
		BP.Vel = interpvel;
		BP.Size = (depth+1)/2;
		BP.Flags = SPF_REPLACE;
		BP.FadeStep = 0;
		BP.Style = STYLE_Normal;
		BP.StartAlpha = max((depth/width), 0.3);
		level.SpawnParticle(BP);

		// Do appearing and drops running down body
		for (int i=drops.size()-1; i>0; i--) {
			let d = drops[i];
			if (d.startlife < 0) { d.startlife++; continue; }
			BP.Pos = oldpos + d.pos;
			BP.Pos.z -= d.vel.z;
			BP.Size = d.size / 2;
			BP.Texture = TexMan.CheckForTexture ("");
			BP.StartAlpha = d.size / (d.maxsize + 1);
			BP.Lifetime = 1;
			BP.Accel.Z = 0;
			BP.Vel = interpvel;
			BP.Vel.Z += d.vel.z;

			if (d.size >= d.maxsize) {
				d.vel.z = clamp(
					d.vel.z + frandom[ubw](-0.01, 0.01),
					-0.25, 0);
			}
			d.pos += d.vel;
			d.size = min(d.size + frandom[ubw](0.01, 0.1), d.maxsize);

			// allow flinging off
			if (interpvel.length() > 5) {
				BP.Lifetime = random[ubw](10,20);
				BP.Size = d.size / 3;
			}

			// Drop free after a bit
			if (d.pos.z < d.maxz && random[ubw](1,5) == 1) {
				BP.Accel.Z = -bleeder.gravity * 0.5;
				BP.Lifetime = random[ubw](10,20);
				BP.Vel.Z += d.vel.z;
				d.destroy();
				drops.delete(i);
			}

			level.SpawnParticle(BP);
		}
		drops.shrinktofit();
		oldpos = off;
	}

	// static string WoundDescription(int newsize) {
		// int sevmax = WoundInfo.severity.size()-1;
		// int typmax = WoundInfo.type.size()-1;
		// int parmax = WoundInfo.bodypart.size()-1;
		// return string.format(
			// "%s %s, %s",
			// WoundInfo.severity[random[uas_wi](0, sevmax)],
			// WoundInfo.type[random[uas_wi](0, typmax)],
			// WoundInfo.bodypart[random[uas_wi](0, parmax)]
		// );
	// }

	static UaS_BleedingWound Create(HDBleedingWound bw) {
		UaS_BleedingWound uw = new("UaS_BleedingWound");
		// Copy stuff from original wound
		uw.bleeder = bw.bleeder;
		uw.source = bw.source;
		uw.depth = bw.depth;
		uw.width = bw.width;
		uw.patched = bw.patched;
		uw.sealed = bw.sealed;
		uw.regenrate = bw.regenrate;
		uw.damagetype = bw.damagetype;
		uw.location = bw.location;
		// Add expanded details
		if (bw.location == (-999, -999)) { uw.location = (frandom[ubw](0,360), frandom[ubw](0.1, 0.90)); /*console.printf("randomized location");*/ }
		if (bw.location.y >= 0.85) { uw.type = UWL_HEAD; /*console.printf("headwound!");*/ }
		//console.printf("location "..uw.location);
		console.printf("new wound width %d depth %d", bw.width, bw.depth);
		return uw;
	}

	override void bleedout() {
		//blood supply is lost from wound
		let hdp=hdplayerpawn(bleeder);
		int bleedrate=int(width);
		if(bleedrate<1){
			double www=width-int(width);
			if(frandom(0,1)<www)bleedrate=1;
		}
		int bleeds=(bleedrate>>3)+random(-1,1);

		if(hdp){
			int dm=(random(10,int(bleedrate))-random(0,hdp.bloodpressure))*4/10;
			if(dm>0){
				hdp.damagemobj(
					hdp,source,dm,"bleedout",
					DMG_THRUSTLESS
					|(hdp.bloodloss>HDCONST_MAXBLOODLOSS?DMG_FORCED:0)
				);
				// Maybe spawn a droplet at the wound
				for (int i=0; i<=dm<<2; i++) {
					double avgsize = (width + depth) / 2.0;
					let newdrop = UaS_BloodParticle(new("UaS_BloodParticle"));
					newdrop.pos.x = frandom[ubw](-avgsize, avgsize) * 0.05;
					newdrop.pos.y = frandom[ubw](-avgsize, avgsize) * 0.05;
					newdrop.pos.z = frandom[ubw](-avgsize, avgsize) * 0.05;
					newdrop.size = 0;
					newdrop.maxsize = frandom[ubw](1,2);
					newdrop.maxz = frandom[ubw](-8, -5);
					newdrop.startlife = 0-i;
					drops.push(newdrop);
				}
				console.printf("bled "..dm<<2);
			}else bleeds=0;
		}else{
			int bled=bleeder.damagemobj(bleeder,source,bleedrate,"bleedout",DMG_NO_PAIN|DMG_THRUSTLESS);
			if(bleeder&&bleeder.health<1&&width<frandom(10,60))bleeder.deathsound="";
		}
		while(bleeds>0){
			bleeds--;
			spawnblood();
		}
	}


	static const string[] w_severity = {
		"minor","small","shallow",
		"superficial","moderate","medium",
		"large","deep","serious","critical" };
	static const string[] w_type = {
		"incision","laceration","puncture",
		"avulsion","penetration" };
	static const string[] w_bodypart = {
		"chest","abdomen","pelvis",
		"upper back","lower back",
		"left shoulder","right shoulder",
		"left upper arm","right upper arm",
		"left forearm","right forearm",
		"left hip","right hip",
		"left thigh","right thigh",
		"left calf","right calf",
		"left shin","right shin"
	};
}
enum UaS_BodyParts {
	UWL_L_ARM,
	UWL_R_ARM,
	UWL_L_LEG,
	UWL_R_LEG,
	UWL_TORSO,
	UWL_JUNCTIONAL,
	UWL_HEAD
}
